import {
  computed,
  createSSRApp,
  defineComponent,
  h,
  isReactive,
  markRaw,
  onMounted,
  onUnmounted,
  reactive,
  ref,
  shallowRef,
  watch
} from "./chunk-KHR3CTJW.js";
import {
  require_cjs,
  require_lib
} from "./chunk-FF3V7QFL.js";
import {
  axios_default
} from "./chunk-MNU4NV32.js";
import {
  __commonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@inertiajs/core/dist/index.esm.js
var import_deepmerge = __toESM(require_cjs());
var D = __toESM(require_lib());
function L(r, e) {
  let t;
  return function(...i) {
    clearTimeout(t), t = setTimeout(() => r.apply(this, i), e);
  };
}
function P(r, e) {
  return document.dispatchEvent(new CustomEvent(`inertia:${r}`, e));
}
var X = (r) => P("before", { cancelable: true, detail: { visit: r } });
var ue = (r) => P("error", { detail: { errors: r } });
var pe = (r) => P("exception", { cancelable: true, detail: { exception: r } });
var de = (r) => P("finish", { detail: { visit: r } });
var he = (r) => P("invalid", { cancelable: true, detail: { response: r } });
var R = (r) => P("navigate", { detail: { page: r } });
var me = (r) => P("progress", { detail: { progress: r } });
var fe = (r) => P("start", { detail: { visit: r } });
var ge = (r) => P("success", { detail: { page: r } });
var ve = (r, e) => P("prefetched", { detail: { fetchedAt: Date.now(), response: r.data, visit: e } });
var be = (r) => P("prefetching", { detail: { visit: r } });
var u = class {
  static set(e, t) {
    typeof window < "u" && window.sessionStorage.setItem(e, JSON.stringify(t));
  }
  static get(e) {
    if (typeof window < "u") return JSON.parse(window.sessionStorage.getItem(e) || "null");
  }
  static merge(e, t) {
    let i = this.get(e);
    i === null ? this.set(e, t) : this.set(e, { ...i, ...t });
  }
  static remove(e) {
    typeof window < "u" && window.sessionStorage.removeItem(e);
  }
  static removeNested(e, t) {
    let i = this.get(e);
    i !== null && (delete i[t], this.set(e, i));
  }
  static exists(e) {
    try {
      return this.get(e) !== null;
    } catch {
      return false;
    }
  }
  static clear() {
    typeof window < "u" && window.sessionStorage.clear();
  }
};
u.locationVisitKey = "inertiaLocationVisit";
var ye = async (r) => {
  if (typeof window > "u") throw new Error("Unable to encrypt history");
  let e = we(), t = await Se(), i = await Ke(t);
  if (!i) throw new Error("Unable to encrypt history");
  return await Ne(e, i, r);
};
var C = { key: "historyKey", iv: "historyIv" };
var Pe = async (r) => {
  let e = we(), t = await Se();
  if (!t) throw new Error("Unable to decrypt history");
  return await $e(e, t, r);
};
var Ne = async (r, e, t) => {
  if (typeof window > "u") throw new Error("Unable to encrypt history");
  if (typeof window.crypto.subtle > "u") return console.warn("Encryption is not supported in this environment. SSL is required."), Promise.resolve(t);
  let i = new TextEncoder(), s = JSON.stringify(t), a = new Uint8Array(s.length * 3), c = i.encodeInto(s, a);
  return window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r }, e, a.subarray(0, c.written));
};
var $e = async (r, e, t) => {
  if (typeof window.crypto.subtle > "u") return console.warn("Decryption is not supported in this environment. SSL is required."), Promise.resolve(t);
  let i = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: r }, e, t);
  return JSON.parse(new TextDecoder().decode(i));
};
var we = () => {
  let r = u.get(C.iv);
  if (r) return new Uint8Array(r);
  let e = window.crypto.getRandomValues(new Uint8Array(12));
  return u.set(C.iv, Array.from(e)), e;
};
var Ge = async () => typeof window.crypto.subtle > "u" ? (console.warn("Encryption is not supported in this environment. SSL is required."), Promise.resolve(null)) : window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
var Be = async (r) => {
  if (typeof window.crypto.subtle > "u") return console.warn("Encryption is not supported in this environment. SSL is required."), Promise.resolve();
  let e = await window.crypto.subtle.exportKey("raw", r);
  u.set(C.key, Array.from(new Uint8Array(e)));
};
var Ke = async (r) => {
  if (r) return r;
  let e = await Ge();
  return e ? (await Be(e), e) : null;
};
var Se = async () => {
  let r = u.get(C.key);
  return r ? await window.crypto.subtle.importKey("raw", new Uint8Array(r), { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]) : null;
};
var v = class {
  static save(e) {
    o.replaceState({ ...e, scrollRegions: Array.from(this.regions()).map((t) => ({ top: t.scrollTop, left: t.scrollLeft })) });
  }
  static regions() {
    return document.querySelectorAll("[scroll-region]");
  }
  static reset(e) {
    typeof window < "u" && window.scrollTo(0, 0), this.regions().forEach((t) => {
      typeof t.scrollTo == "function" ? t.scrollTo(0, 0) : (t.scrollTop = 0, t.scrollLeft = 0);
    }), this.save(e), window.location.hash && setTimeout(() => {
      var _a;
      return (_a = document.getElementById(window.location.hash.slice(1))) == null ? void 0 : _a.scrollIntoView();
    });
  }
  static restore(e) {
    e.scrollRegions && this.regions().forEach((t, i) => {
      let s = e.scrollRegions[i];
      s && (typeof t.scrollTo == "function" ? t.scrollTo(s.left, s.top) : (t.scrollTop = s.top, t.scrollLeft = s.left));
    });
  }
  static onScroll(e) {
    let t = e.target;
    typeof t.hasAttribute == "function" && t.hasAttribute("scroll-region") && this.save(n.get());
  }
};
function H(r) {
  return r instanceof File || r instanceof Blob || r instanceof FileList && r.length > 0 || r instanceof FormData && Array.from(r.values()).some((e) => H(e)) || typeof r == "object" && r !== null && Object.values(r).some((e) => H(e));
}
var z = (r) => r instanceof FormData;
function _(r, e = new FormData(), t = null) {
  r = r || {};
  for (let i in r) Object.prototype.hasOwnProperty.call(r, i) && Re(e, Ee(t, i), r[i]);
  return e;
}
function Ee(r, e) {
  return r ? r + "[" + e + "]" : e;
}
function Re(r, e, t) {
  if (Array.isArray(t)) return Array.from(t.keys()).forEach((i) => Re(r, Ee(e, i.toString()), t[i]));
  if (t instanceof Date) return r.append(e, t.toISOString());
  if (t instanceof File) return r.append(e, t, t.name);
  if (t instanceof Blob) return r.append(e, t);
  if (typeof t == "boolean") return r.append(e, t ? "1" : "0");
  if (typeof t == "string") return r.append(e, t);
  if (typeof t == "number") return r.append(e, `${t}`);
  if (t == null) return r.append(e, "");
  _(t, r, e);
}
function y(r) {
  return new URL(r.toString(), typeof window > "u" ? void 0 : window.location.toString());
}
var xe = (r, e, t, i, s) => {
  let a = typeof r == "string" ? y(r) : r;
  if ((H(e) || i) && !z(e) && (e = _(e)), z(e)) return [a, e];
  let [c, d] = qe(t, a, e, s);
  return [y(c), d];
};
function qe(r, e, t, i = "brackets") {
  let s = /^https?:\/\//.test(e.toString()), a = s || e.toString().startsWith("/"), c = !a && !e.toString().startsWith("#") && !e.toString().startsWith("?"), d = e.toString().includes("?") || r === "get" && Object.keys(t).length, m2 = e.toString().includes("#"), h2 = new URL(e.toString(), "http://localhost");
  return r === "get" && Object.keys(t).length && (h2.search = D.stringify((0, import_deepmerge.default)(D.parse(h2.search, { ignoreQueryPrefix: true }), t), { encodeValuesOnly: true, arrayFormat: i }), t = {}), [[s ? `${h2.protocol}//${h2.host}` : "", a ? h2.pathname : "", c ? h2.pathname.substring(1) : "", d ? h2.search : "", m2 ? h2.hash : ""].join(""), t];
}
function V(r) {
  return r = new URL(r.href), r.hash = "", r;
}
var Y = (r, e) => {
  r.hash && !e.hash && V(r).href === e.href && (e.hash = r.hash);
};
var k = (r, e) => V(r).href === V(e).href;
var Z = class {
  constructor() {
    this.componentId = {};
    this.listeners = [];
    this.isFirstPageLoad = true;
    this.cleared = false;
  }
  init({ initialPage: e, swapComponent: t, resolveComponent: i }) {
    return this.page = e, this.swapComponent = t, this.resolveComponent = i, this;
  }
  set(e, { replace: t = false, preserveScroll: i = false, preserveState: s = false } = {}) {
    this.componentId = {};
    let a = this.componentId;
    return e.clearHistory && o.clear(), this.resolve(e.component).then((c) => {
      if (a !== this.componentId) return;
      e.scrollRegions ?? (e.scrollRegions = []), e.rememberedState ?? (e.rememberedState = {});
      let d = typeof window < "u" ? window.location : new URL(e.url);
      return t = t || k(y(e.url), d), new Promise((m2) => {
        t ? o.replaceState(e, () => m2(null)) : o.pushState(e, () => m2(null));
      }).then(() => {
        let m2 = !this.isTheSame(e);
        return this.page = e, this.cleared = false, m2 && this.fireEventsFor("newComponent"), this.isFirstPageLoad && this.fireEventsFor("firstLoad"), this.isFirstPageLoad = false, this.swap({ component: c, page: e, preserveState: s }).then(() => {
          i || v.reset(e), w.fireInternalEvent("loadDeferredProps"), t || R(e);
        });
      });
    });
  }
  setQuietly(e, { preserveState: t = false } = {}) {
    return this.resolve(e.component).then((i) => (this.page = e, this.cleared = false, this.swap({ component: i, page: e, preserveState: t })));
  }
  clear() {
    this.cleared = true;
  }
  isCleared() {
    return this.cleared;
  }
  get() {
    return this.page;
  }
  merge(e) {
    this.page = { ...this.page, ...e };
  }
  setUrlHash(e) {
    this.page.url += e;
  }
  remember(e) {
    this.page.rememberedState = e;
  }
  scrollRegions(e) {
    this.page.scrollRegions = e;
  }
  swap({ component: e, page: t, preserveState: i }) {
    return this.swapComponent({ component: e, page: t, preserveState: i });
  }
  resolve(e) {
    return Promise.resolve(this.resolveComponent(e));
  }
  isTheSame(e) {
    return this.page.component === e.component;
  }
  on(e, t) {
    return this.listeners.push({ event: e, callback: t }), () => {
      this.listeners = this.listeners.filter((i) => i.event !== e && i.callback !== t);
    };
  }
  fireEventsFor(e) {
    this.listeners.filter((t) => t.event === e).forEach((t) => t.callback());
  }
};
var n = new Z();
var M = typeof window > "u";
var ee = class {
  constructor() {
    this.rememberedState = "rememberedState";
    this.scrollRegions = "scrollRegions";
    this.preserveUrl = false;
    this.current = {};
    this.queue = [];
    this.initialState = null;
  }
  remember(e, t) {
    var _a;
    this.replaceState({ ...n.get(), rememberedState: { ...((_a = n.get()) == null ? void 0 : _a.rememberedState) ?? {}, [t]: e } });
  }
  restore(e) {
    var _a, _b;
    if (!M) return (_b = (_a = this.initialState) == null ? void 0 : _a[this.rememberedState]) == null ? void 0 : _b[e];
  }
  pushState(e, t = null) {
    M || this.preserveUrl || (this.current = e, this.addToQueue(() => this.getPageData(e).then((i) => {
      window.history.pushState({ page: i, timestamp: Date.now() }, "", e.url), t && t();
    })));
  }
  getPageData(e) {
    return new Promise((t) => e.encryptHistory ? ye(e).then(t) : t(e));
  }
  processQueue() {
    let e = this.queue.shift();
    return e ? e().then(() => this.processQueue()) : Promise.resolve();
  }
  decrypt(e = null) {
    var _a;
    if (M) return Promise.resolve(e ?? n.get());
    let t = e ?? ((_a = window.history.state) == null ? void 0 : _a.page);
    return this.decryptPageData(t).then((i) => {
      if (!i) throw new Error("Unable to decrypt history");
      return this.initialState === null ? this.initialState = i ?? void 0 : this.current = i ?? {}, i;
    });
  }
  decryptPageData(e) {
    return e instanceof ArrayBuffer ? Pe(e) : Promise.resolve(e);
  }
  replaceState(e, t = null) {
    n.merge(e), !(M || this.preserveUrl) && (this.current = e, this.addToQueue(() => this.getPageData(e).then((i) => {
      window.history.replaceState({ page: i, timestamp: Date.now() }, "", e.url), t && t();
    })));
  }
  addToQueue(e) {
    this.queue.push(e), this.processQueue();
  }
  getState(e, t) {
    var _a;
    return ((_a = this.current) == null ? void 0 : _a[e]) ?? t;
  }
  deleteState(e) {
    this.current[e] !== void 0 && (delete this.current[e], this.replaceState(this.current));
  }
  hasAnyState() {
    return !!this.getAllState();
  }
  clear() {
    u.remove(C.key), u.remove(C.iv);
  }
  isValidState(e) {
    return !!e.page;
  }
  getAllState() {
    return this.current;
  }
};
var o = new ee();
var te = class {
  constructor() {
    this.internalListeners = [];
  }
  init() {
    typeof window < "u" && window.addEventListener("popstate", this.handlePopstateEvent.bind(this)), typeof document < "u" && document.addEventListener("scroll", L(v.onScroll.bind(v), 100), true);
  }
  onGlobalEvent(e, t) {
    let i = (s) => {
      let a = t(s);
      s.cancelable && !s.defaultPrevented && a === false && s.preventDefault();
    };
    return this.registerListener(`inertia:${e}`, i);
  }
  on(e, t) {
    return this.internalListeners.push({ event: e, listener: t }), () => {
      this.internalListeners = this.internalListeners.filter((i) => i.listener !== t);
    };
  }
  onMissingHistoryItem() {
    n.clear(), this.fireInternalEvent("missingHistoryItem");
  }
  fireInternalEvent(e) {
    this.internalListeners.filter((t) => t.event === e).forEach((t) => t.listener());
  }
  registerListener(e, t) {
    return document.addEventListener(e, t), () => document.removeEventListener(e, t);
  }
  handlePopstateEvent(e) {
    let t = e.state || null;
    if (t === null) {
      let i = y(n.get().url);
      i.hash = window.location.hash, o.replaceState({ ...n.get(), url: i.href }), v.reset(n.get());
      return;
    }
    if (o.isValidState(t)) {
      o.decrypt(t.page).then((i) => {
        n.setQuietly(i, { preserveState: false }).then(() => {
          v.restore(n.get()), R(n.get());
        });
      }).catch(() => {
        this.onMissingHistoryItem();
      });
      return;
    }
    this.onMissingHistoryItem();
  }
};
var w = new te();
var re = class {
  constructor() {
    typeof window < "u" && (window == null ? void 0 : window.performance.getEntriesByType("navigation").length) > 0 ? this.type = window.performance.getEntriesByType("navigation")[0].type : this.type = "navigate";
  }
  get() {
    return this.type;
  }
  isBackForward() {
    return this.type === "back_forward";
  }
  isReload() {
    return this.type === "reload";
  }
};
var ie = new re();
var N = class {
  static handle() {
    this.clearRememberedStateOnReload(), [this.handleBackForward, this.handleLocation, this.handleDefault].find((t) => t.bind(this)());
  }
  static clearRememberedStateOnReload() {
    ie.isReload() && o.deleteState(o.rememberedState);
  }
  static handleBackForward() {
    return !ie.isBackForward() || !o.hasAnyState() ? false : (o.decrypt().then((e) => {
      n.set(e, { preserveScroll: true, preserveState: true }).then(() => {
        v.restore(n.get()), R(n.get());
      });
    }).catch(() => {
      w.onMissingHistoryItem();
    }), true);
  }
  static handleLocation() {
    if (!u.exists(u.locationVisitKey)) return false;
    let e = u.get(u.locationVisitKey) || {};
    return u.remove(u.locationVisitKey), typeof window < "u" && n.setUrlHash(window.location.hash), o.decrypt().then(() => {
      let t = o.getState(o.rememberedState, {}), i = o.getState(o.scrollRegions, []);
      n.remember(t), n.scrollRegions(i), n.set(n.get(), { preserveScroll: e.preserveScroll, preserveState: true }).then(() => {
        e.preserveScroll && v.restore(n.get()), R(n.get());
      });
    }).catch(() => {
      w.onMissingHistoryItem();
    }), true;
  }
  static handleDefault() {
    typeof window < "u" && n.setUrlHash(window.location.hash), n.set(n.get(), { preserveState: true }).then(() => {
      R(n.get());
    });
  }
};
var $ = class {
  constructor(e, t, i) {
    this.id = null;
    this.throttle = false;
    this.keepAlive = false;
    this.cbCount = 0;
    this.keepAlive = i.keepAlive ?? false, this.cb = t, this.interval = e, (i.autoStart ?? true) && this.start();
  }
  stop() {
    this.id && clearInterval(this.id);
  }
  start() {
    typeof window > "u" || (this.stop(), this.id = window.setInterval(() => {
      (!this.throttle || this.cbCount % 10 === 0) && this.cb(), this.throttle && this.cbCount++;
    }, this.interval));
  }
  isInBackground(e) {
    this.throttle = this.keepAlive ? false : e, this.throttle && (this.cbCount = 0);
  }
};
var se = class {
  constructor() {
    this.polls = [];
    this.setupVisibilityListener();
  }
  add(e, t, i) {
    let s = new $(e, t, i);
    return this.polls.push(s), { stop: () => s.stop(), start: () => s.start() };
  }
  clear() {
    this.polls.forEach((e) => e.stop()), this.polls = [];
  }
  setupVisibilityListener() {
    typeof document > "u" || document.addEventListener("visibilitychange", () => {
      this.polls.forEach((e) => e.isInBackground(document.hidden));
    }, false);
  }
};
var Ce = new se();
var ne = (r, e, t) => {
  if (r === e) return true;
  for (let i in r) if (!t.includes(i) && r[i] !== e[i] && !We(r[i], e[i])) return false;
  return true;
};
var We = (r, e) => {
  switch (typeof r) {
    case "object":
      return ne(r, e, []);
    case "function":
      return r.toString() === e.toString();
    default:
      return r === e;
  }
};
var Qe = { ms: 1, s: 1e3, m: 6e4, h: 36e5, d: 864e5 };
var oe = (r) => {
  if (typeof r == "number") return r;
  for (let [e, t] of Object.entries(Qe)) if (r.endsWith(e)) return parseFloat(r) * t;
  return parseInt(r);
};
var ae = class {
  constructor() {
    this.cached = [];
    this.inFlightRequests = [];
    this.removalTimers = [];
    this.currentUseId = null;
  }
  add(e, t, { cacheFor: i }) {
    if (this.findInFlight(e)) return Promise.resolve();
    let a = this.findCached(e);
    if (!e.fresh && a && a.staleTimestamp > Date.now()) return Promise.resolve();
    let [c, d] = this.extractStaleValues(i), m2 = new Promise((h2, l) => {
      t({ ...e, onCancel: () => {
        this.remove(e), e.onCancel(), l();
      }, onError: (g2) => {
        this.remove(e), e.onError(g2), l();
      }, onPrefetching(g2) {
        e.onPrefetching(g2);
      }, onPrefetched(g2, J) {
        e.onPrefetched(g2, J);
      }, onPrefetchResponse(g2) {
        h2(g2);
      } });
    }).then((h2) => (this.remove(e), this.cached.push({ params: { ...e }, staleTimestamp: Date.now() + c, response: m2, singleUse: i === 0, timestamp: Date.now(), inFlight: false }), this.scheduleForRemoval(e, d), this.inFlightRequests = this.inFlightRequests.filter((l) => !this.paramsAreEqual(l.params, e)), h2.handlePrefetch(), h2));
    return this.inFlightRequests.push({ params: { ...e }, response: m2, staleTimestamp: null, inFlight: true }), m2;
  }
  removeAll() {
    this.cached = [], this.removalTimers.forEach((e) => {
      clearTimeout(e.timer);
    }), this.removalTimers = [];
  }
  remove(e) {
    this.cached = this.cached.filter((t) => !this.paramsAreEqual(t.params, e)), this.clearTimer(e);
  }
  extractStaleValues(e) {
    let [t, i] = this.cacheForToStaleAndExpires(e);
    return [oe(t), oe(i)];
  }
  cacheForToStaleAndExpires(e) {
    if (!Array.isArray(e)) return [e, e];
    switch (e.length) {
      case 0:
        return [0, 0];
      case 1:
        return [e[0], e[0]];
      default:
        return [e[0], e[1]];
    }
  }
  clearTimer(e) {
    let t = this.removalTimers.find((i) => this.paramsAreEqual(i.params, e));
    t && (clearTimeout(t.timer), this.removalTimers = this.removalTimers.filter((i) => i !== t));
  }
  scheduleForRemoval(e, t) {
    if (!(typeof window > "u") && (this.clearTimer(e), t > 0)) {
      let i = window.setTimeout(() => this.remove(e), t);
      this.removalTimers.push({ params: e, timer: i });
    }
  }
  get(e) {
    return this.findCached(e) || this.findInFlight(e);
  }
  use(e, t) {
    let i = `${t.url.pathname}-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    return this.currentUseId = i, e.response.then((s) => {
      if (this.currentUseId === i) return s.mergeParams({ ...t, onPrefetched: () => {
      } }), this.removeSingleUseItems(t), s.handle();
    });
  }
  removeSingleUseItems(e) {
    this.cached = this.cached.filter((t) => this.paramsAreEqual(t.params, e) ? !t.singleUse : true);
  }
  findCached(e) {
    return this.cached.find((t) => this.paramsAreEqual(t.params, e)) || null;
  }
  findInFlight(e) {
    return this.inFlightRequests.find((t) => this.paramsAreEqual(t.params, e)) || null;
  }
  paramsAreEqual(e, t) {
    return ne(e, t, ["showProgress", "replace", "prefetch", "onBefore", "onStart", "onProgress", "onFinish", "onCancel", "onSuccess", "onError", "onPrefetched", "onCancelToken", "onPrefetching", "async"]);
  }
};
var x = new ae();
var F = class {
  constructor(e) {
    this.callbacks = [];
    if (!e.prefetch) this.params = e;
    else {
      let t = { onBefore: this.wrapCallback(e, "onBefore"), onStart: this.wrapCallback(e, "onStart"), onProgress: this.wrapCallback(e, "onProgress"), onFinish: this.wrapCallback(e, "onFinish"), onCancel: this.wrapCallback(e, "onCancel"), onSuccess: this.wrapCallback(e, "onSuccess"), onError: this.wrapCallback(e, "onError"), onCancelToken: this.wrapCallback(e, "onCancelToken"), onPrefetched: this.wrapCallback(e, "onPrefetched"), onPrefetching: this.wrapCallback(e, "onPrefetching") };
      this.params = { ...e, ...t, onPrefetchResponse: e.onPrefetchResponse || (() => {
      }) };
    }
  }
  static create(e) {
    return new F(e);
  }
  data() {
    return this.params.method === "get" ? {} : this.params.data;
  }
  queryParams() {
    return this.params.method === "get" ? this.params.data : {};
  }
  isPartial() {
    return this.params.only.length > 0 || this.params.except.length > 0 || this.params.reset.length > 0;
  }
  onCancelToken(e) {
    this.params.onCancelToken({ cancel: e });
  }
  markAsFinished() {
    this.params.completed = true, this.params.cancelled = false, this.params.interrupted = false;
  }
  markAsCancelled({ cancelled: e = true, interrupted: t = false }) {
    this.params.onCancel(), this.params.completed = false, this.params.cancelled = e, this.params.interrupted = t;
  }
  wasCancelledAtAll() {
    return this.params.cancelled || this.params.interrupted;
  }
  onFinish() {
    this.params.onFinish(this.params);
  }
  onStart() {
    this.params.onStart(this.params);
  }
  onPrefetching() {
    this.params.onPrefetching(this.params);
  }
  onPrefetchResponse(e) {
    this.params.onPrefetchResponse && this.params.onPrefetchResponse(e);
  }
  all() {
    return this.params;
  }
  headers() {
    let e = { ...this.params.headers };
    this.isPartial() && (e["X-Inertia-Partial-Component"] = n.get().component);
    let t = this.params.only.concat(this.params.reset);
    return t.length > 0 && (e["X-Inertia-Partial-Data"] = t.join(",")), this.params.except.length > 0 && (e["X-Inertia-Partial-Except"] = this.params.except.join(",")), this.params.reset.length > 0 && (e["X-Inertia-Reset"] = this.params.reset.join(",")), this.params.errorBag && this.params.errorBag.length > 0 && (e["X-Inertia-Error-Bag"] = this.params.errorBag), e;
  }
  setPreserveOptions(e) {
    this.params.preserveScroll = this.resolvePreserveOption(this.params.preserveScroll, e), this.params.preserveState = this.resolvePreserveOption(this.params.preserveState, e);
  }
  runCallbacks() {
    this.callbacks.forEach(({ name: e, args: t }) => {
      this.params[e](...t);
    });
  }
  merge(e) {
    this.params = { ...this.params, ...e };
  }
  wrapCallback(e, t) {
    return (...i) => {
      this.recordCallback(t, i), e[t](...i);
    };
  }
  recordCallback(e, t) {
    this.callbacks.push({ name: e, args: t });
  }
  resolvePreserveOption(e, t) {
    return typeof e == "function" ? e(t) : e === "errors" ? Object.keys(t.props.errors || {}).length > 0 : e;
  }
};
var Te = { modal: null, listener: null, show(r) {
  typeof r == "object" && (r = `All Inertia requests must receive a valid Inertia response, however a plain JSON response was received.<hr>${JSON.stringify(r)}`);
  let e = document.createElement("html");
  e.innerHTML = r, e.querySelectorAll("a").forEach((i) => i.setAttribute("target", "_top")), this.modal = document.createElement("div"), this.modal.style.position = "fixed", this.modal.style.width = "100vw", this.modal.style.height = "100vh", this.modal.style.padding = "50px", this.modal.style.boxSizing = "border-box", this.modal.style.backgroundColor = "rgba(0, 0, 0, .6)", this.modal.style.zIndex = 2e5, this.modal.addEventListener("click", () => this.hide());
  let t = document.createElement("iframe");
  if (t.style.backgroundColor = "white", t.style.borderRadius = "5px", t.style.width = "100%", t.style.height = "100%", this.modal.appendChild(t), document.body.prepend(this.modal), document.body.style.overflow = "hidden", !t.contentWindow) throw new Error("iframe not yet ready.");
  t.contentWindow.document.open(), t.contentWindow.document.write(e.outerHTML), t.contentWindow.document.close(), this.listener = this.hideOnEscape.bind(this), document.addEventListener("keydown", this.listener);
}, hide() {
  this.modal.outerHTML = "", this.modal = null, document.body.style.overflow = "visible", document.removeEventListener("keydown", this.listener);
}, hideOnEscape(r) {
  r.keyCode === 27 && this.hide();
} };
var le = class {
  constructor() {
    this.queue = [];
    this.processing = false;
  }
  add(e) {
    this.queue.push(e);
  }
  async process() {
    return this.processing || (this.processing = true, await this.processQueue(), this.processing = false), Promise.resolve();
  }
  async processQueue() {
    let e = this.queue.shift();
    return e ? (await e.process(), this.processQueue()) : Promise.resolve();
  }
};
var Ae = new le();
var T = class {
  constructor(e, t, i) {
    this.requestParams = e;
    this.response = t;
    this.originatingPage = i;
  }
  static create(e, t, i) {
    return new T(e, t, i);
  }
  async handlePrefetch() {
    k(this.requestParams.all().url, window.location) && this.handle();
  }
  async handle() {
    return Ae.add(this), Ae.process();
  }
  async process() {
    if (this.requestParams.all().prefetch) return this.requestParams.all().prefetch = false, this.requestParams.all().onPrefetched(this.response, this.requestParams.all()), ve(this.response, this.requestParams.all()), Promise.resolve();
    if (this.requestParams.runCallbacks(), !this.isInertiaResponse()) return this.handleNonInertiaResponse();
    await o.processQueue(), o.preserveUrl = this.requestParams.all().preserveUrl, await this.setPage();
    let e = n.get().props.errors || {};
    if (Object.keys(e).length > 0) {
      let t = this.getScopedErrors(e);
      return ue(t), this.requestParams.all().onError(t);
    }
    ge(n.get()), await this.requestParams.all().onSuccess(n.get()), o.preserveUrl = false;
  }
  mergeParams(e) {
    this.requestParams.merge(e);
  }
  async handleNonInertiaResponse() {
    if (this.isLocationVisit()) {
      let t = y(this.getHeader("x-inertia-location"));
      return Y(this.requestParams.all().url, t), this.locationVisit(t);
    }
    let e = { ...this.response, data: this.getDataFromResponse(this.response.data) };
    if (he(e)) return Te.show(e.data);
  }
  isInertiaResponse() {
    return this.hasHeader("x-inertia");
  }
  hasStatus(e) {
    return this.response.status === e;
  }
  getHeader(e) {
    return this.response.headers[e];
  }
  hasHeader(e) {
    return this.getHeader(e) !== void 0;
  }
  isLocationVisit() {
    return this.hasStatus(409) && this.hasHeader("x-inertia-location");
  }
  locationVisit(e) {
    try {
      if (u.set(u.locationVisitKey, { preserveScroll: this.requestParams.all().preserveScroll === true }), typeof window > "u") return;
      k(window.location, e) ? window.location.reload() : window.location.href = e.href;
    } catch {
      return false;
    }
  }
  async setPage() {
    let e = this.getDataFromResponse(this.response.data);
    return this.shouldSetPage(e) ? (this.mergeProps(e), await this.setRememberedState(e), this.requestParams.setPreserveOptions(e), e.url = o.preserveUrl ? n.get().url : this.pageUrl(e), n.set(e, { replace: this.requestParams.all().replace, preserveScroll: this.requestParams.all().preserveScroll, preserveState: this.requestParams.all().preserveState })) : Promise.resolve();
  }
  getDataFromResponse(e) {
    if (typeof e != "string") return e;
    try {
      return JSON.parse(e);
    } catch {
      return e;
    }
  }
  shouldSetPage(e) {
    if (!this.requestParams.all().async || this.originatingPage.component !== e.component) return true;
    if (this.originatingPage.component !== n.get().component) return false;
    let t = y(this.originatingPage.url), i = y(n.get().url);
    return t.origin === i.origin && t.pathname === i.pathname;
  }
  pageUrl(e) {
    let t = y(e.url);
    return Y(this.requestParams.all().url, t), t.href.split(t.host).pop();
  }
  mergeProps(e) {
    this.requestParams.isPartial() && e.component === n.get().component && ((e.mergeProps || []).forEach((i) => {
      let s = e.props[i];
      Array.isArray(s) ? e.props[i] = [...n.get().props[i] || [], ...s] : typeof s == "object" && (e.props[i] = { ...n.get().props[i] || [], ...s });
    }), e.props = { ...n.get().props, ...e.props });
  }
  async setRememberedState(e) {
    let t = await o.getState(o.rememberedState, {});
    this.requestParams.all().preserveState && t && e.component === n.get().component && (e.rememberedState = t);
  }
  getScopedErrors(e) {
    return this.requestParams.all().errorBag ? e[this.requestParams.all().errorBag || ""] || {} : e;
  }
};
var A = class {
  constructor(e, t) {
    this.page = t;
    this.requestHasFinished = false;
    this.requestParams = F.create(e), this.cancelToken = new AbortController();
  }
  static create(e, t) {
    return new A(e, t);
  }
  async send() {
    this.requestParams.onCancelToken(() => this.cancel({ cancelled: true })), fe(this.requestParams.all()), this.requestParams.onStart(), this.requestParams.all().prefetch && (this.requestParams.onPrefetching(), be(this.requestParams.all()));
    let e = this.requestParams.all().prefetch;
    return axios_default({ method: this.requestParams.all().method, url: V(this.requestParams.all().url).href, data: this.requestParams.data(), params: this.requestParams.queryParams(), signal: this.cancelToken.signal, headers: this.getHeaders(), onUploadProgress: this.onProgress.bind(this), responseType: "text" }).then((t) => (this.response = T.create(this.requestParams, t, this.page), this.response.handle())).catch((t) => (t == null ? void 0 : t.response) ? (this.response = T.create(this.requestParams, t.response, this.page), this.response.handle()) : Promise.reject(t)).catch((t) => {
      if (!axios_default.isCancel(t) && pe(t)) return Promise.reject(t);
    }).finally(() => {
      this.finish(), e && this.response && this.requestParams.onPrefetchResponse(this.response);
    });
  }
  finish() {
    this.requestParams.wasCancelledAtAll() || (this.requestParams.markAsFinished(), this.fireFinishEvents());
  }
  fireFinishEvents() {
    this.requestHasFinished || (this.requestHasFinished = true, de(this.requestParams.all()), this.requestParams.onFinish());
  }
  cancel({ cancelled: e = false, interrupted: t = false }) {
    this.requestHasFinished || (this.cancelToken.abort(), this.requestParams.markAsCancelled({ cancelled: e, interrupted: t }), this.fireFinishEvents());
  }
  onProgress(e) {
    this.requestParams.data() instanceof FormData && (e.percentage = e.progress ? Math.round(e.progress * 100) : 0, me(e), this.requestParams.all().onProgress(e));
  }
  getHeaders() {
    let e = { ...this.requestParams.headers(), Accept: "text/html, application/xhtml+xml", "X-Requested-With": "XMLHttpRequest", "X-Inertia": true };
    return n.get().version && (e["X-Inertia-Version"] = n.get().version), e;
  }
};
var O = class {
  constructor({ maxConcurrent: e, interruptible: t }) {
    this.requests = [];
    this.maxConcurrent = e, this.interruptible = t;
  }
  send(e) {
    this.requests.push(e), e.send().then(() => {
      this.requests = this.requests.filter((t) => t !== e);
    });
  }
  interruptInFlight() {
    this.cancel({ interrupted: true }, false);
  }
  cancelInFlight() {
    this.cancel({ cancelled: true }, true);
  }
  cancel({ cancelled: e = false, interrupted: t = false } = {}, i) {
    var _a;
    if (!this.shouldCancel(i)) return;
    (_a = this.requests.shift()) == null ? void 0 : _a.cancel({ interrupted: t, cancelled: e });
  }
  shouldCancel(e) {
    return e ? true : this.interruptible && this.requests.length >= this.maxConcurrent;
  }
};
var G = class {
  constructor() {
    this.syncRequestStream = new O({ maxConcurrent: 1, interruptible: true });
    this.asyncRequestStream = new O({ maxConcurrent: 1 / 0, interruptible: false });
  }
  init({ initialPage: e, resolveComponent: t, swapComponent: i }) {
    n.init({ initialPage: e, resolveComponent: t, swapComponent: i }), N.handle(), w.init(), w.on("missingHistoryItem", () => {
      typeof window < "u" && this.visit(window.location.href, { preserveState: true, preserveScroll: true, replace: true });
    }), w.on("loadDeferredProps", () => {
      this.loadDeferredProps();
    });
  }
  get(e, t = {}, i = {}) {
    return this.visit(e, { ...i, method: "get", data: t });
  }
  post(e, t = {}, i = {}) {
    return this.visit(e, { preserveState: true, ...i, method: "post", data: t });
  }
  put(e, t = {}, i = {}) {
    return this.visit(e, { preserveState: true, ...i, method: "put", data: t });
  }
  patch(e, t = {}, i = {}) {
    return this.visit(e, { preserveState: true, ...i, method: "patch", data: t });
  }
  delete(e, t = {}) {
    return this.visit(e, { preserveState: true, ...t, method: "delete" });
  }
  reload(e = {}) {
    if (!(typeof window > "u")) return this.visit(window.location.href, { ...e, preserveScroll: true, preserveState: true, async: true, headers: { ...e.headers || {}, "Cache-Control": "no-cache" } });
  }
  remember(e, t = "default") {
    o.remember(e, t);
  }
  restore(e = "default") {
    return o.restore(e);
  }
  on(e, t) {
    return w.onGlobalEvent(e, t);
  }
  cancel() {
    this.syncRequestStream.cancelInFlight();
  }
  cancelAll() {
    this.asyncRequestStream.cancelInFlight(), this.syncRequestStream.cancelInFlight();
  }
  poll(e, t = {}, i = {}) {
    return Ce.add(e, () => this.reload(t), { autoStart: i.autoStart ?? true, keepAlive: i.keepAlive ?? false });
  }
  visit(e, t = {}) {
    let i = this.getPendingVisit(e, { ...t, showProgress: t.showProgress ?? !t.async }), s = this.getVisitEvents(t);
    if (s.onBefore(i) === false || !X(i)) return;
    let a = i.async ? this.asyncRequestStream : this.syncRequestStream;
    a.interruptInFlight(), !n.isCleared() && !i.preserveUrl && v.save(n.get());
    let c = { ...i, ...s }, d = x.get(c);
    d ? (B(d.inFlight), x.use(d, c)) : (B(true), a.send(A.create(c, n.get())));
  }
  getCached(e, t = {}) {
    return x.findCached(this.getPrefetchParams(e, t));
  }
  flush(e, t = {}) {
    x.remove(this.getPrefetchParams(e, t));
  }
  flushAll() {
    x.removeAll();
  }
  getPrefetching(e, t = {}) {
    return x.findInFlight(this.getPrefetchParams(e, t));
  }
  prefetch(e, t = {}, { cacheFor: i }) {
    if (t.method !== "get") throw new Error("Prefetch requests must use the GET method");
    let s = this.getPendingVisit(e, { ...t, async: true, showProgress: false, prefetch: true }), a = s.url.origin + s.url.pathname + s.url.search, c = window.location.origin + window.location.pathname + window.location.search;
    if (a === c) return;
    let d = this.getVisitEvents(t);
    if (d.onBefore(s) === false || !X(s)) return;
    K(), this.asyncRequestStream.interruptInFlight();
    let m2 = { ...s, ...d };
    (() => new Promise((l) => {
      let g2 = () => {
        n.get() ? l() : setTimeout(g2, 50);
      };
      g2();
    }))().then(() => {
      x.add(m2, (l) => {
        this.asyncRequestStream.send(A.create(l, n.get()));
      }, { cacheFor: i });
    });
  }
  clearHistory() {
    o.clear();
  }
  decryptHistory() {
    return o.decrypt();
  }
  replace(e) {
    this.clientVisit(e, { replace: true });
  }
  push(e) {
    this.clientVisit(e);
  }
  clientVisit(e, { replace: t = false } = {}) {
    let i = n.get(), s = typeof e.props == "function" ? e.props(i.props) : e.props ?? i.props;
    n.set({ ...i, ...e, props: s }, { replace: t, preserveScroll: e.preserveScroll, preserveState: e.preserveState });
  }
  getPrefetchParams(e, t) {
    return { ...this.getPendingVisit(e, { ...t, async: true, showProgress: false, prefetch: true }), ...this.getVisitEvents(t) };
  }
  getPendingVisit(e, t, i = {}) {
    let s = { method: "get", data: {}, replace: false, preserveScroll: false, preserveState: false, only: [], except: [], headers: {}, errorBag: "", forceFormData: false, queryStringArrayFormat: "brackets", async: false, showProgress: true, fresh: false, reset: [], preserveUrl: false, prefetch: false, ...t }, [a, c] = xe(e, s.data, s.method, s.forceFormData, s.queryStringArrayFormat);
    return { cancelled: false, completed: false, interrupted: false, ...s, ...i, url: a, data: c };
  }
  getVisitEvents(e) {
    return { onCancelToken: e.onCancelToken || (() => {
    }), onBefore: e.onBefore || (() => {
    }), onStart: e.onStart || (() => {
    }), onProgress: e.onProgress || (() => {
    }), onFinish: e.onFinish || (() => {
    }), onCancel: e.onCancel || (() => {
    }), onSuccess: e.onSuccess || (() => {
    }), onError: e.onError || (() => {
    }), onPrefetched: e.onPrefetched || (() => {
    }), onPrefetching: e.onPrefetching || (() => {
    }) };
  }
  loadDeferredProps() {
    var _a;
    let e = (_a = n.get()) == null ? void 0 : _a.deferredProps;
    e && Object.entries(e).forEach(([t, i]) => {
      this.reload({ only: i });
    });
  }
};
var Je = { buildDOMElement(r) {
  let e = document.createElement("template");
  e.innerHTML = r;
  let t = e.content.firstChild;
  if (!r.startsWith("<script ")) return t;
  let i = document.createElement("script");
  return i.innerHTML = t.innerHTML, t.getAttributeNames().forEach((s) => {
    i.setAttribute(s, t.getAttribute(s) || "");
  }), i;
}, isInertiaManagedElement(r) {
  return r.nodeType === Node.ELEMENT_NODE && r.getAttribute("inertia") !== null;
}, findMatchingElementIndex(r, e) {
  let t = r.getAttribute("inertia");
  return t !== null ? e.findIndex((i) => i.getAttribute("inertia") === t) : -1;
}, update: L(function(r) {
  let e = r.map((i) => this.buildDOMElement(i));
  Array.from(document.head.childNodes).filter((i) => this.isInertiaManagedElement(i)).forEach((i) => {
    var _a, _b;
    let s = this.findMatchingElementIndex(i, e);
    if (s === -1) {
      (_a = i == null ? void 0 : i.parentNode) == null ? void 0 : _a.removeChild(i);
      return;
    }
    let a = e.splice(s, 1)[0];
    a && !i.isEqualNode(a) && ((_b = i == null ? void 0 : i.parentNode) == null ? void 0 : _b.replaceChild(a, i));
  }), e.forEach((i) => document.head.appendChild(i));
}, 1) };
function Fe(r, e, t) {
  let i = {}, s = 0;
  function a() {
    let l = s += 1;
    return i[l] = [], l.toString();
  }
  function c(l) {
    l === null || Object.keys(i).indexOf(l) === -1 || (delete i[l], h2());
  }
  function d(l, g2 = []) {
    l !== null && Object.keys(i).indexOf(l) > -1 && (i[l] = g2), h2();
  }
  function m2() {
    let l = e(""), g2 = { ...l ? { title: `<title inertia="">${l}</title>` } : {} }, J = Object.values(i).reduce((S, E) => S.concat(E), []).reduce((S, E) => {
      if (E.indexOf("<") === -1) return S;
      if (E.indexOf("<title ") === 0) {
        let U = E.match(/(<title [^>]+>)(.*?)(<\/title>)/);
        return S.title = U ? `${U[1]}${e(U[2])}${U[3]}` : E, S;
      }
      let ce = E.match(/ inertia="[^"]+"/);
      return ce ? S[ce[0]] = E : S[Object.keys(S).length] = E, S;
    }, g2);
    return Object.values(J);
  }
  function h2() {
    r ? t(m2()) : Je.update(m2());
  }
  return h2(), { forceUpdate: h2, createProvider: function() {
    let l = a();
    return { update: (g2) => d(l, g2), disconnect: () => c(l) };
  } };
}
var p = "nprogress";
var f = { minimum: 0.08, easing: "linear", positionUsing: "translate3d", speed: 200, trickle: true, trickleSpeed: 200, showSpinner: true, barSelector: '[role="bar"]', spinnerSelector: '[role="spinner"]', parent: "body", color: "#29d", includeCSS: true, template: ['<div class="bar" role="bar">', '<div class="peg"></div>', "</div>", '<div class="spinner" role="spinner">', '<div class="spinner-icon"></div>', "</div>"].join("") };
var q = null;
var Xe = (r) => {
  Object.assign(f, r), f.includeCSS && tt(f.color);
};
var W = (r) => {
  let e = Ie();
  r = He(r, f.minimum, 1), q = r === 1 ? null : r;
  let t = _e(!e), i = t.querySelector(f.barSelector), s = f.speed, a = f.easing;
  t.offsetWidth, et((c) => {
    let d = (() => f.positionUsing === "translate3d" ? { transition: `all ${s}ms ${a}`, transform: `translate3d(${j(r)}%,0,0)` } : f.positionUsing === "translate" ? { transition: `all ${s}ms ${a}`, transform: `translate(${j(r)}%,0)` } : { marginLeft: `${j(r)}%` })();
    for (let m2 in d) i.style[m2] = d[m2];
    if (r !== 1) return setTimeout(c, s);
    t.style.transition = "none", t.style.opacity = "1", t.offsetWidth, setTimeout(() => {
      t.style.transition = `all ${s}ms linear`, t.style.opacity = "0", setTimeout(() => {
        Ue(), c();
      }, s);
    }, s);
  });
};
var Ie = () => typeof q == "number";
var Le = () => {
  q || W(0);
  let r = function() {
    setTimeout(function() {
      q && (ke(), r());
    }, f.trickleSpeed);
  };
  f.trickle && r();
};
var ze = (r) => {
  !r && !q || (ke(0.3 + 0.5 * Math.random()), W(1));
};
var ke = (r) => {
  let e = q;
  if (e === null) return Le();
  if (!(e > 1)) return r = typeof r == "number" ? r : (() => {
    let t = { 0.1: [0, 0.2], 0.04: [0.2, 0.5], 0.02: [0.5, 0.8], 5e-3: [0.8, 0.99] };
    for (let i in t) if (e >= t[i][0] && e < t[i][1]) return parseFloat(i);
    return 0;
  })(), W(He(e + r, 0, 0.994));
};
var _e = (r) => {
  var _a;
  if (Ye()) return document.getElementById(p);
  document.documentElement.classList.add(`${p}-busy`);
  let e = document.createElement("div");
  e.id = p, e.innerHTML = f.template;
  let t = e.querySelector(f.barSelector), i = r ? "-100" : j(q || 0), s = Oe();
  return t.style.transition = "all 0 linear", t.style.transform = `translate3d(${i}%,0,0)`, f.showSpinner || ((_a = e.querySelector(f.spinnerSelector)) == null ? void 0 : _a.remove()), s !== document.body && s.classList.add(`${p}-custom-parent`), s.appendChild(e), e;
};
var Oe = () => Ze(f.parent) ? f.parent : document.querySelector(f.parent);
var Ue = () => {
  var _a;
  document.documentElement.classList.remove(`${p}-busy`), Oe().classList.remove(`${p}-custom-parent`), (_a = document.getElementById(p)) == null ? void 0 : _a.remove();
};
var Ye = () => document.getElementById(p) !== null;
var Ze = (r) => typeof HTMLElement == "object" ? r instanceof HTMLElement : r && typeof r == "object" && r.nodeType === 1 && typeof r.nodeName == "string";
function He(r, e, t) {
  return r < e ? e : r > t ? t : r;
}
var j = (r) => (-1 + r) * 100;
var et = /* @__PURE__ */ (() => {
  let r = [], e = () => {
    let t = r.shift();
    t && t(e);
  };
  return (t) => {
    r.push(t), r.length === 1 && e();
  };
})();
var tt = (r) => {
  let e = document.createElement("style");
  e.textContent = `
    #${p} {
      pointer-events: none;
    }

    #${p} .bar {
      background: ${r};

      position: fixed;
      z-index: 1031;
      top: 0;
      left: 0;

      width: 100%;
      height: 2px;
    }

    #${p} .peg {
      display: block;
      position: absolute;
      right: 0px;
      width: 100px;
      height: 100%;
      box-shadow: 0 0 10px ${r}, 0 0 5px ${r};
      opacity: 1.0;

      transform: rotate(3deg) translate(0px, -4px);
    }

    #${p} .spinner {
      display: block;
      position: fixed;
      z-index: 1031;
      top: 15px;
      right: 15px;
    }

    #${p} .spinner-icon {
      width: 18px;
      height: 18px;
      box-sizing: border-box;

      border: solid 2px transparent;
      border-top-color: ${r};
      border-left-color: ${r};
      border-radius: 50%;

      animation: ${p}-spinner 400ms linear infinite;
    }

    .${p}-custom-parent {
      overflow: hidden;
      position: relative;
    }

    .${p}-custom-parent #${p} .spinner,
    .${p}-custom-parent #${p} .bar {
      position: absolute;
    }

    @keyframes ${p}-spinner {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `, document.head.appendChild(e);
};
var I = (() => {
  if (typeof document > "u") return null;
  let r = document.createElement("style");
  return r.innerHTML = `#${p} { display: none; }`, r;
})();
var rt = () => {
  if (I && document.head.contains(I)) return document.head.removeChild(I);
};
var it = () => {
  I && !document.head.contains(I) && document.head.appendChild(I);
};
var b = { configure: Xe, isStarted: Ie, done: ze, set: W, remove: Ue, start: Le, status: q, show: rt, hide: it };
var Q = 0;
var B = (r = false) => {
  Q = Math.max(0, Q - 1), (r || Q === 0) && b.show();
};
var K = () => {
  Q++, b.hide();
};
function st(r) {
  document.addEventListener("inertia:start", (e) => nt(e, r)), document.addEventListener("inertia:progress", ot);
}
function nt(r, e) {
  r.detail.visit.showProgress || K();
  let t = setTimeout(() => b.start(), e);
  document.addEventListener("inertia:finish", (i) => at(i, t), { once: true });
}
function ot(r) {
  var _a;
  b.isStarted() && ((_a = r.detail.progress) == null ? void 0 : _a.percentage) && b.set(Math.max(b.status, r.detail.progress.percentage / 100 * 0.9));
}
function at(r, e) {
  clearTimeout(e), b.isStarted() && (r.detail.visit.completed ? b.done() : r.detail.visit.interrupted ? b.set(0) : r.detail.visit.cancelled && (b.done(), b.remove()));
}
function De({ delay: r = 250, color: e = "#29d", includeCSS: t = true, showSpinner: i = false } = {}) {
  st(r), b.configure({ showSpinner: i, includeCSS: t, color: e });
}
function Me(r) {
  let e = r.currentTarget.tagName.toLowerCase() === "a";
  return !(r.target && (r == null ? void 0 : r.target).isContentEditable || r.defaultPrevented || e && r.which > 1 || e && r.altKey || e && r.ctrlKey || e && r.metaKey || e && r.shiftKey || e && "button" in r && r.button !== 0);
}
var Gr = new G();

// node_modules/@inertiajs/vue3/dist/index.esm.js
var import_lodash = __toESM(require_lodash());
var import_lodash2 = __toESM(require_lodash());
var import_lodash3 = __toESM(require_lodash2());
var import_lodash4 = __toESM(require_lodash());
var z2 = { created() {
  if (!this.$options.remember) return;
  Array.isArray(this.$options.remember) && (this.$options.remember = { data: this.$options.remember }), typeof this.$options.remember == "string" && (this.$options.remember = { data: [this.$options.remember] }), typeof this.$options.remember.data == "string" && (this.$options.remember = { data: [this.$options.remember.data] });
  let e = this.$options.remember.key instanceof Function ? this.$options.remember.key.call(this) : this.$options.remember.key, t = Gr.restore(e), n2 = this.$options.remember.data.filter((o2) => !(this[o2] !== null && typeof this[o2] == "object" && this[o2].__rememberable === false)), s = (o2) => this[o2] !== null && typeof this[o2] == "object" && typeof this[o2].__remember == "function" && typeof this[o2].__restore == "function";
  n2.forEach((o2) => {
    this[o2] !== void 0 && t !== void 0 && t[o2] !== void 0 && (s(o2) ? this[o2].__restore(t[o2]) : this[o2] = t[o2]), this.$watch(o2, () => {
      Gr.remember(n2.reduce((l, u2) => ({ ...l, [u2]: (0, import_lodash.default)(s(u2) ? this[u2].__remember() : this[u2]) }), {}), e);
    }, { immediate: true, deep: true });
  });
} };
var R2 = z2;
function C2(e, t) {
  let n2 = typeof e == "string" ? e : null, s = typeof e == "string" ? t : e, o2 = n2 ? Gr.restore(n2) : null, l = typeof s == "object" ? (0, import_lodash2.default)(s) : (0, import_lodash2.default)(s()), u2 = null, f2 = null, d = (r) => r, y2 = reactive({ ...o2 ? o2.data : (0, import_lodash2.default)(l), isDirty: false, errors: o2 ? o2.errors : {}, hasErrors: false, processing: false, progress: null, wasSuccessful: false, recentlySuccessful: false, data() {
    return Object.keys(l).reduce((r, i) => (r[i] = this[i], r), {});
  }, transform(r) {
    return d = r, this;
  }, defaults(r, i) {
    if (typeof s == "function") throw new Error("You cannot call `defaults()` when using a function to define your form data.");
    return typeof r > "u" ? l = this.data() : l = Object.assign({}, (0, import_lodash2.default)(l), typeof r == "string" ? { [r]: i } : r), this;
  }, reset(...r) {
    let i = typeof s == "object" ? (0, import_lodash2.default)(l) : (0, import_lodash2.default)(s()), a = (0, import_lodash2.default)(i);
    return r.length === 0 ? (l = a, Object.assign(this, i)) : Object.keys(i).filter((c) => r.includes(c)).forEach((c) => {
      l[c] = a[c], this[c] = i[c];
    }), this;
  }, setError(r, i) {
    return Object.assign(this.errors, typeof r == "string" ? { [r]: i } : r), this.hasErrors = Object.keys(this.errors).length > 0, this;
  }, clearErrors(...r) {
    return this.errors = Object.keys(this.errors).reduce((i, a) => ({ ...i, ...r.length > 0 && !r.includes(a) ? { [a]: this.errors[a] } : {} }), {}), this.hasErrors = Object.keys(this.errors).length > 0, this;
  }, submit(r, i, a = {}) {
    let c = d(this.data()), v2 = { ...a, onCancelToken: (p2) => {
      if (u2 = p2, a.onCancelToken) return a.onCancelToken(p2);
    }, onBefore: (p2) => {
      if (this.wasSuccessful = false, this.recentlySuccessful = false, clearTimeout(f2), a.onBefore) return a.onBefore(p2);
    }, onStart: (p2) => {
      if (this.processing = true, a.onStart) return a.onStart(p2);
    }, onProgress: (p2) => {
      if (this.progress = p2, a.onProgress) return a.onProgress(p2);
    }, onSuccess: async (p2) => {
      this.processing = false, this.progress = null, this.clearErrors(), this.wasSuccessful = true, this.recentlySuccessful = true, f2 = setTimeout(() => this.recentlySuccessful = false, 2e3);
      let F2 = a.onSuccess ? await a.onSuccess(p2) : null;
      return l = (0, import_lodash2.default)(this.data()), this.isDirty = false, F2;
    }, onError: (p2) => {
      if (this.processing = false, this.progress = null, this.clearErrors().setError(p2), a.onError) return a.onError(p2);
    }, onCancel: () => {
      if (this.processing = false, this.progress = null, a.onCancel) return a.onCancel();
    }, onFinish: (p2) => {
      if (this.processing = false, this.progress = null, u2 = null, a.onFinish) return a.onFinish(p2);
    } };
    r === "delete" ? Gr.delete(i, { ...v2, data: c }) : Gr[r](i, c, v2);
  }, get(r, i) {
    this.submit("get", r, i);
  }, post(r, i) {
    this.submit("post", r, i);
  }, put(r, i) {
    this.submit("put", r, i);
  }, patch(r, i) {
    this.submit("patch", r, i);
  }, delete(r, i) {
    this.submit("delete", r, i);
  }, cancel() {
    u2 && u2.cancel();
  }, __rememberable: n2 === null, __remember() {
    return { data: this.data(), errors: this.errors };
  }, __restore(r) {
    Object.assign(this, r.data), this.setError(r.errors);
  } });
  return watch(y2, (r) => {
    y2.isDirty = !(0, import_lodash3.default)(y2.data(), l), n2 && Gr.remember((0, import_lodash2.default)(r.__remember()), n2);
  }, { immediate: true, deep: true }), y2;
}
var g = ref(null);
var m = ref(null);
var w2 = shallowRef(null);
var k2 = ref(null);
var O2 = null;
var oe2 = defineComponent({ name: "Inertia", props: { initialPage: { type: Object, required: true }, initialComponent: { type: Object, required: false }, resolveComponent: { type: Function, required: false }, titleCallback: { type: Function, required: false, default: (e) => e }, onHeadUpdate: { type: Function, required: false, default: () => () => {
} } }, setup({ initialPage: e, initialComponent: t, resolveComponent: n2, titleCallback: s, onHeadUpdate: o2 }) {
  g.value = t ? markRaw(t) : null, m.value = e, k2.value = null;
  let l = typeof window > "u";
  return O2 = Fe(l, s, o2), l || (Gr.init({ initialPage: e, resolveComponent: n2, swapComponent: async (u2) => {
    g.value = markRaw(u2.component), m.value = u2.page, k2.value = u2.preserveState ? k2.value : Date.now();
  } }), Gr.on("navigate", () => O2.forceUpdate())), () => {
    if (g.value) {
      g.value.inheritAttrs = !!g.value.inheritAttrs;
      let u2 = h(g.value, { ...m.value.props, key: k2.value });
      return w2.value && (g.value.layout = w2.value, w2.value = null), g.value.layout ? typeof g.value.layout == "function" ? g.value.layout(h, u2) : (Array.isArray(g.value.layout) ? g.value.layout : [g.value.layout]).concat(u2).reverse().reduce((f2, d) => (d.inheritAttrs = !!d.inheritAttrs, h(d, { ...m.value.props }, () => f2))) : u2;
    }
  };
} });
var M2 = oe2;
var N2 = { install(e) {
  Gr.form = C2, Object.defineProperty(e.config.globalProperties, "$inertia", { get: () => Gr }), Object.defineProperty(e.config.globalProperties, "$page", { get: () => m.value }), Object.defineProperty(e.config.globalProperties, "$headManager", { get: () => O2 }), e.mixin(R2);
} };
function ne2() {
  return reactive({ props: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.props;
  }), url: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.url;
  }), component: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.component;
  }), version: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.version;
  }), clearHistory: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.clearHistory;
  }), deferredProps: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.deferredProps;
  }), mergeProps: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.mergeProps;
  }), scrollRegions: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.scrollRegions;
  }), rememberedState: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.rememberedState;
  }), encryptHistory: computed(() => {
    var _a;
    return (_a = m.value) == null ? void 0 : _a.encryptHistory;
  }) });
}
async function L2({ id: e = "app", resolve: t, setup: n2, title: s, progress: o2 = {}, page: l, render: u2 }) {
  let f2 = typeof window > "u", d = f2 ? null : document.getElementById(e), y2 = l || JSON.parse(d.dataset.page), r = (c) => Promise.resolve(t(c)).then((v2) => v2.default || v2), i = [], a = await Promise.all([r(y2.component), Gr.decryptHistory().catch(() => {
  })]).then(([c]) => n2({ el: d, App: M2, props: { initialPage: y2, initialComponent: c, resolveComponent: r, titleCallback: s, onHeadUpdate: f2 ? (v2) => i = v2 : null }, plugin: N2 }));
  if (!f2 && o2 && De(o2), f2) {
    let c = await u2(createSSRApp({ render: () => h("div", { id: e, "data-page": JSON.stringify(y2), innerHTML: a ? u2(a) : "" }) }));
    return { head: i, body: c };
  }
}
var pe2 = defineComponent({ name: "Deferred", props: { data: { type: [String, Array], required: true } }, render() {
  let e = Array.isArray(this.$props.data) ? this.$props.data : [this.$props.data];
  if (!this.$slots.fallback) throw new Error("`<Deferred>` requires a `<template #fallback>` slot");
  return e.every((t) => this.$page.props[t] !== void 0) ? this.$slots.default() : this.$slots.fallback();
} });
var fe2 = defineComponent({ props: { title: { type: String, required: false } }, data() {
  return { provider: this.$headManager.createProvider() };
}, beforeUnmount() {
  this.provider.disconnect();
}, methods: { isUnaryTag(e) {
  return ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"].indexOf(e.type) > -1;
}, renderTagStart(e) {
  e.props = e.props || {}, e.props.inertia = e.props["head-key"] !== void 0 ? e.props["head-key"] : "";
  let t = Object.keys(e.props).reduce((n2, s) => {
    let o2 = e.props[s];
    return ["key", "head-key"].includes(s) ? n2 : o2 === "" ? n2 + ` ${s}` : n2 + ` ${s}="${o2}"`;
  }, "");
  return `<${e.type}${t}>`;
}, renderTagChildren(e) {
  return typeof e.children == "string" ? e.children : e.children.reduce((t, n2) => t + this.renderTag(n2), "");
}, isFunctionNode(e) {
  return typeof e.type == "function";
}, isComponentNode(e) {
  return typeof e.type == "object";
}, isCommentNode(e) {
  return /(comment|cmt)/i.test(e.type.toString());
}, isFragmentNode(e) {
  return /(fragment|fgt|symbol\(\))/i.test(e.type.toString());
}, isTextNode(e) {
  return /(text|txt)/i.test(e.type.toString());
}, renderTag(e) {
  if (this.isTextNode(e)) return e.children;
  if (this.isFragmentNode(e)) return "";
  if (this.isCommentNode(e)) return "";
  let t = this.renderTagStart(e);
  return e.children && (t += this.renderTagChildren(e)), this.isUnaryTag(e) || (t += `</${e.type}>`), t;
}, addTitleElement(e) {
  return this.title && !e.find((t) => t.startsWith("<title")) && e.push(`<title inertia>${this.title}</title>`), e;
}, renderNodes(e) {
  return this.addTitleElement(e.flatMap((t) => this.resolveNode(t)).map((t) => this.renderTag(t)).filter((t) => t));
}, resolveNode(e) {
  return this.isFunctionNode(e) ? this.resolveNode(e.type()) : this.isComponentNode(e) ? (console.warn("Using components in the <Head> component is not supported."), []) : this.isTextNode(e) && e.children ? e : this.isFragmentNode(e) && e.children ? e.children.flatMap((t) => this.resolveNode(t)) : this.isCommentNode(e) ? [] : e;
} }, render() {
  this.provider.update(this.renderNodes(this.$slots.default ? this.$slots.default() : []));
} });
var de2 = fe2;
var be2 = defineComponent({ name: "Link", props: { as: { type: String, default: "a" }, data: { type: Object, default: () => ({}) }, href: { type: String, required: true }, method: { type: String, default: "get" }, replace: { type: Boolean, default: false }, preserveScroll: { type: Boolean, default: false }, preserveState: { type: Boolean, default: null }, only: { type: Array, default: () => [] }, except: { type: Array, default: () => [] }, headers: { type: Object, default: () => ({}) }, queryStringArrayFormat: { type: String, default: "brackets" }, async: { type: Boolean, default: false }, prefetch: { type: [Boolean, String, Array], default: false }, cacheFor: { type: [Number, String, Array], default: 0 }, onStart: { type: Function, default: (e) => {
} }, onProgress: { type: Function, default: () => {
} }, onFinish: { type: Function, default: () => {
} }, onBefore: { type: Function, default: () => {
} }, onCancel: { type: Function, default: () => {
} }, onSuccess: { type: Function, default: () => {
} }, onError: { type: Function, default: () => {
} }, onCancelToken: { type: Function, default: () => {
} } }, setup(e, { slots: t, attrs: n2 }) {
  let s = ref(0), o2 = ref(null), l = (() => e.prefetch === true ? ["hover"] : e.prefetch === false ? [] : Array.isArray(e.prefetch) ? e.prefetch : [e.prefetch])(), u2 = (() => e.cacheFor !== 0 ? e.cacheFor : l.length === 1 && l[0] === "click" ? 0 : 3e4)();
  onMounted(() => {
    l.includes("mount") && p2();
  }), onUnmounted(() => {
    clearTimeout(o2.value);
  });
  let f2 = e.method.toLowerCase(), d = f2 !== "get" ? "button" : e.as.toLowerCase(), y2 = computed(() => qe(f2, e.href || "", e.data, e.queryStringArrayFormat)), r = computed(() => y2.value[0]), i = computed(() => y2.value[1]), a = computed(() => ({ a: { href: r.value }, button: { type: "button" } })), c = { data: i.value, method: f2, replace: e.replace, preserveScroll: e.preserveScroll, preserveState: e.preserveState ?? f2 !== "get", only: e.only, except: e.except, headers: e.headers, async: e.async }, v2 = { ...c, onCancelToken: e.onCancelToken, onBefore: e.onBefore, onStart: (h2) => {
    s.value++, e.onStart(h2);
  }, onProgress: e.onProgress, onFinish: (h2) => {
    s.value--, e.onFinish(h2);
  }, onCancel: e.onCancel, onSuccess: e.onSuccess, onError: e.onError }, p2 = () => {
    Gr.prefetch(r.value, c, { cacheFor: u2 });
  }, F2 = { onClick: (h2) => {
    Me(h2) && (h2.preventDefault(), Gr.visit(r.value, v2));
  } }, J = { onMouseenter: () => {
    o2.value = setTimeout(() => {
      p2();
    }, 75);
  }, onMouseleave: () => {
    clearTimeout(o2.value);
  }, onClick: F2.onClick }, Y2 = { onMousedown: (h2) => {
    Me(h2) && (h2.preventDefault(), p2());
  }, onMouseup: (h2) => {
    h2.preventDefault(), Gr.visit(r.value, v2);
  }, onClick: (h2) => {
    Me(h2) && h2.preventDefault();
  } };
  return () => h(d, { ...n2, ...a.value[d] || {}, "data-loading": s.value > 0 ? "" : void 0, ...(() => l.includes("hover") ? J : l.includes("click") ? Y2 : F2)() }, t);
} });
var Pe2 = be2;
function B2(e, t = {}, n2 = { keepAlive: false, autoStart: true }) {
  let { stop: s, start: o2 } = Gr.poll(e, t, { ...n2, autoStart: false });
  return onMounted(() => {
    (n2.autoStart ?? true) && o2();
  }), onUnmounted(() => {
    s();
  }), { stop: s, start: o2 };
}
function q2(e = {}) {
  let t = ref(false), n2 = ref(null), s = ref(false), o2 = typeof window > "u" ? null : Gr.getCached(window.location.pathname, e), l = typeof window > "u" ? null : Gr.getPrefetching(window.location.pathname, e);
  n2.value = (o2 == null ? void 0 : o2.staleTimestamp) || null, t.value = l !== null, s.value = o2 !== null;
  let u2, f2;
  return onMounted(() => {
    f2 = Gr.on("prefetching", (d) => {
      d.detail.visit.url.pathname === window.location.pathname && (t.value = true);
    }), u2 = Gr.on("prefetched", (d) => {
      d.detail.visit.url.pathname === window.location.pathname && (t.value = false, s.value = true);
    });
  }), onUnmounted(() => {
    u2(), f2();
  }), { lastUpdatedAt: n2, isPrefetching: t, isPrefetched: s, flush: () => Gr.flush(window.location.pathname, e) };
}
function W2(e, t) {
  if (typeof e == "object" && e !== null && e.__rememberable === false) return e;
  let n2 = Gr.restore(t), s = isReactive(e) ? reactive : ref, o2 = typeof e.__remember == "function" && typeof e.__restore == "function", l = s(n2 === void 0 ? e : o2 ? e.__restore(n2) : n2);
  return watch(l, (u2) => {
    Gr.remember((0, import_lodash4.default)(o2 ? e.__remember() : u2), t);
  }, { immediate: true, deep: true }), l;
}
var Ie2 = defineComponent({ name: "WhenVisible", props: { data: { type: [String, Array] }, params: { type: Object }, buffer: { type: Number, default: 0 }, as: { type: String, default: "div" }, always: { type: Boolean, default: false } }, data() {
  return { loaded: false, fetching: false, observer: null };
}, unmounted() {
  var _a;
  (_a = this.observer) == null ? void 0 : _a.disconnect();
}, mounted() {
  this.observer = new IntersectionObserver((e) => {
    if (!e[0].isIntersecting || (this.$props.always || this.observer.disconnect(), this.fetching)) return;
    this.fetching = true;
    let t = this.getReloadParams();
    Gr.reload({ ...t, onStart: (n2) => {
      var _a;
      this.fetching = true, (_a = t.onStart) == null ? void 0 : _a.call(t, n2);
    }, onFinish: (n2) => {
      var _a;
      this.loaded = true, this.fetching = false, (_a = t.onFinish) == null ? void 0 : _a.call(t, n2);
    } });
  }, { rootMargin: `${this.$props.buffer}px` }), this.observer.observe(this.$el.nextSibling);
}, methods: { getReloadParams() {
  if (this.$props.data) return { only: Array.isArray(this.$props.data) ? this.$props.data : [this.$props.data] };
  if (!this.$props.params) throw new Error("You must provide either a `data` or `params` prop.");
  return this.$props.params;
} }, render() {
  let e = [];
  return (this.$props.always || !this.loaded) && e.push(h(this.$props.as)), this.loaded ? this.$slots.default && e.push(this.$slots.default()) : e.push(this.$slots.fallback ? this.$slots.fallback() : null), e;
} });
export {
  pe2 as Deferred,
  de2 as Head,
  Pe2 as Link,
  Ie2 as WhenVisible,
  L2 as createInertiaApp,
  Gr as router,
  C2 as useForm,
  ne2 as usePage,
  B2 as usePoll,
  q2 as usePrefetch,
  W2 as useRemember
};
/*! Bundled license information:

@inertiajs/core/dist/index.esm.js:
  (* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
   * @license MIT *)
*/
//# sourceMappingURL=@inertiajs_vue3.js.map
